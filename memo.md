# 005 数字ブロック
* greadyにいく."="を忘れたため1WA


# 008 Nを言っちゃダメゲーム
* Nを言っちゃダメゲームは自分がN-1を言えれば勝ちゲーム
* 相手がKを言ったらK+1が作れるので相手が最初に言える数で(N-1) - (K+1)を作る。
* これらを0以上になるまで拡張するとその数が言えるかどうかで勝敗が決まると言っていい

# 018 うーさー暗号
* シーザー暗号はN右にずらしたものである
* 今回はs[i]はi文字ずらしたものが与えられるので復元する
* ずらす文字はiだと文字列が26文字以上の場合ずらしすぎてしまうのでmod 26でやる

# 021 平均の差
* よくよく考えるとmax-minになる
* max と次に大きい数を同じグループに入れても平均は下がる.同様にminの場合は上がる

# 022 括弧の対応
* 累積和を取って同じ値だったらで行けると思ったけどWA
* 1233211234554321など値だけなら同じになってしまうことがある
* またどことどこが対応しているかなどよくわからなくなるので'('なら右に見てく.')'なら左に見ていくようにした

# 024 数当てゲーム
* 最初UFでいいのかとか思ったけど違った
* カウントして最大値でやった

# 026 シャッフルゲーム
* swapするだけ

# 029 パワーアップ
* gready

# 032 貯金箱の憂鬱
* 1円硬貨から順番に大きいお金の硬貨に変えていく
* オーバーフローもないので特に気をつけることない

# 035 タイパー高橋
* 問題に書いてある式をそのままやればOK

# 040 多項式の割り算
わからん

# 046 はじめのn歩
* 割り切れるならb/a そうじゃないならb/a+1

# 047 ポケットを叩くとビスケットが2倍
* ポケットに入れたクッキーを叩くと2倍になる
* bitsetを用いて最上位ビット(MSB)のindexを持ってくる
* MSBを作ったことでもう一つのほうで他のbitが立っている所を十分に表すことが出来るため
* ex 10000 - 01111

# 048 ロボットの探索
* 象限ごとに分けて考える
* 1,2象限ならば最初は北を向いていることから向きの交換は一回
* 3,4ならば向きの交換は二回
* ただx=0 や y=0に注意 x=0,y=-1のときは向きの交換は二回なので注意が必要

# 051 やる気の問題
* 数が多い時に合わない.for(ll)にしたらオッケーだった
* このミスは二回目である.しっかり注意しよう.

# 056 消費税
* 普通は(1 + p)にしたいから最初のp /= 100をやるけど誤差が怖い
* 先に掛け算を終了させてから100でわる

# 057 ミリオンダイス
* 一つのダイスの期待値は3.5である
* 普通に3.5 * nをすると数が大きいためオーバーフロー
* intで考えたい 
* 偶数ならば3 * n + n/2 そうじゃないならば 3*n + n/2 + 0.5でオッケー

# 063 ポッキーゲーム
* L - 2*kをやっていく.この回数がans

# 064 XORフィボナッチ数列
* 制約が無茶苦茶でかい
* 愚直にやるともちろんTLEだった
* よく考えるとF_2 = F_1 xor F_0　より周期は3つになる
* これらがわかってればi%3で終わり

# 069 文字を自由に並び替え
* 入れ替えて目的の文字列が作れるかどうかの問題
* mapで管理して終了

# 070 睡眠の重要性
* int s,t; char c; cin >> s >> c >> t;で入力が拾える
* M-mではなくm-M

# 079 過小評価ダメ・ゼッタイ
* 評価が多いものが最終評価
* レベルが6しかないのでcnt++してって一番多いものを検出する

# 082 市松模様
* 実装にめっちゃ時間かかった
* 一個作ってひっくり返せばいいやと思ったけどBWB では意味がないので結局indexが奇数偶数でやった

# 083 最大マッチング
* 名前でびびる
* よくよく考えると4本あるなら11をつくったほうが強い
* 最後に3ボンあるなら1より7のほうがいいので最後につけたらWA
* 数が大きいものを出力するのでもちろん先頭につけねばならない

# 084 悪の３番
* わからず

# 088　次はどっちだ
* 偶数奇数と先手で決める

# 089 どんどんドーナツどーんといこう！
* ドーナツの体積を求める
* 一見内側と外側の半径だけでrはいくつだよと思うが円ということからr = (b-a)/2とわかる
* 後はパップスギルダン

# 098 円を書こう
* 直径なのでdistance*2
* 後は切り上げ

# 099 ジャンピング駒
* 最初全探索するのかとか思ったけどそんなことしなくてよい
* x+2 x-2に移動出来るということはx+1 x-1にいる駒を消せる
* 奇数偶数の数で答えがわかる
* max(奇数の個数、偶数の個数) - min(奇数の個数,偶数の個数)

# 104 国道
* 2分木ということからiの子はi*2+1,i*2+2でアクセスできる
* 今回は実際木を書かなくてもこれらの値を足していけばよい

# 112 ややかしい鶴亀算
* 自分以外の足の本数を言うので全て足してn-1で割れば総本数がでる
* あとは全探索

# 113 宝探し
* x,yを記録しておいてdistanceを出す

# 116 門松列(1)
* 3つのペアを全部調べる
* v[i]が2番目に大きい,v[i+2]が2番目に大きいかをチェックする
